{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FluentIter","text":"<p>Nicer iterator patterns for Python! Chain map, filter, zip, unzip, cycle, skip and scan like there is no tomorrow.</p> <p>Install with</p> <pre><code>pip install fluentiter\n</code></pre> <p>Straight to the API docs \ud83d\udc49</p>"},{"location":"#tldr","title":"TLDR:","text":"<p>With fluentiter you can do this</p> <pre><code>lines = iterator(haystack_csv.split(\"\\n\"))\nheader = [x for x in lines.next().split(\",\") if x.strip(\" \")]\nneedle = (\n    lines.map(lambda line: line.split(\",\"))\n    .map(lambda values: {k: v for k, v in zip(header, values)})\n    .filter(lambda value_dct: value_dct[\"material\"] != \"hay\")\n    .find(lambda value_dct: value_dct[\"type\"] == \"needle\")\n)\n</code></pre> <p>instead of this</p> <pre><code>lines = iter(some_csv.split(\"\\n\"))\nheader = [x for x in next(lines).split(\",\") if x.strip()]\nneedle = next(\n    filter(\n        lambda value_dct: value_dct[\"material\"] != \"hay\",\n        filter(\n            lambda value_dct: value_dct[\"type\"] == \"needle\",\n            map(\n                lambda values: {k: v for k, v in zip(header, values)},\n                map(lambda line: line.split(\",\"), lines),\n            ),\n        ),\n    )\n)\n</code></pre> <p>See the this example for a more complete version.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>To me Pythons iterator functions (i.e. <code>map</code>, <code>filter</code>, <code>zip</code>, etc.) always seemed backward. While generator expressions and list/dict/set comprehensions give you nice left-to-right readability, <code>map</code> and <code>filter</code> force you to read \"inside-out\":</p> <pre><code>[func(x) for x in something if x == y]\nmap(func, filter(lambda x: x == y, something))\n</code></pre> <p>This is not an issue for short an simple statements, as they can be written concisely using expressions, but chaining multiple operations, will result in either many intermediate variable assignements or serious spaghettification.</p>"},{"location":"#how-to-use","title":"How to use","text":"<p>Any <code>Iterable</code> can be turned into a <code>FluentIterator</code> by just passing it to the <code>iterator</code> function:</p> <pre><code>from fluentiter import iterator\nbugs = [\"john\", \"paul\", \"ringo\", \"george\"]\n\nfluent = iterator(bugs)\n# you can now do\n# fluent.map(...).filter(...).cycle(...).scan(...) and so on\n</code></pre> <p>The <code>FluentIterator</code> provides a rich set of methods you can call and chain together to your liking:</p> <p>Of course there are the classic <code>map</code>, <code>filter</code>, and <code>reduce</code> functions, but also some more really useful features like <code>cycle</code> to repeat an iterator forever, <code>find</code> to find an element or even <code>partition</code> to turn your iterator into two.</p> <p>In total <code>FluentIterator</code> provides 35 methods to compose beautiful and easy to follow iteration patterns. Check the API docs to see them all.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>36 cool fresh iterator methods</li> <li>100% Type annotated e.g. <code>iterator([\"foo\", \"bar\"]).map(len).to_list()</code> gets correctly inferred as <code>list[int]</code></li> <li>100% Test coverage</li> <li>0 dependencies outside the Python standard library<sup>1</sup></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>The simplest way to contribute is to open an issue. If you would like to see some feature implemented or found a bug, head over to the issues section.</p>"},{"location":"#developing","title":"Developing","text":"<ol> <li>Clone the repository</li> <li>Install Poetry</li> <li>Install development dependencies with <code>poetry install</code></li> <li>Enter the poetry shell with <code>poetry shell</code></li> </ol>"},{"location":"#guidelines","title":"Guidelines","text":"<p>Your PR should include relevant tests for the changes you are contributing and be fully type annotated. If you are unsure or stuck, please open the PR anyway and we can work it out together.</p> <p>By opening a PR you agree to your code becoming part of the fluentiter package and being published under fluentiters license.</p>"},{"location":"#running-formatting-tests-and-linting","title":"Running formatting, tests, and linting","text":"<ul> <li>Formatting: <code>poe format</code></li> <li>Linting: <code>poe lint</code></li> <li>Tests: <code>poe test</code></li> </ul> <p>All of the above: <code>poe all</code></p>"},{"location":"#viewing-the-coverage-report","title":"Viewing the coverage report","text":"<p>Running <code>coverage html</code> will create a file <code>htmlcov/index.html</code> you can open to view the test coverage report</p>"},{"location":"#special-thanks","title":"Special Thanks","text":"<p>Thank you to all Rust maintainers for creating the Iterator trait, which served as the main source of inspiration.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>Import <code>fluentiter</code> and create a <code>FluentIterator</code>:</p> <p>Go to FluentIterator API for the API docs</p> <ol> <li> <p>Some functions may require the <code>more</code> extra which has more-itertools as a dependency\u00a0\u21a9</p> </li> </ol>"},{"location":"api/","title":"FluentIterator API","text":"<p>Use the <code>iterator</code> function to create a <code>FluentIterator</code>:</p> <pre><code>from fluentiter import iterator\n\nmy_iter = iterator([\"ice\", \"ice\", \"baby\"])\n</code></pre> <p>See below for all the things you can do then.</p>"},{"location":"api/#fluentiter.core.FluentIterator","title":"<code>FluentIterator</code>","text":"<p>             Bases: <code>Generic[T]</code>, <code>Iterator[T]</code></p> <p>Easy to use container for iterables</p>"},{"location":"api/#fluentiter.core.FluentIterator.any","title":"<code>any(func=bool)</code>","text":"<p>Return <code>True</code> if the given function returns <code>True</code> for any element of this iterator, otherwise return <code>False</code>.</p> <p>For an empty iterator this is always <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to evaluate elements, by default bool</p> <code>bool</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether any element of this iterator matches the predicate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"one\", \"2\", \"three\"]).any(lambda x: x.is_digit())\nTrue\n&gt;&gt;&gt; iterator([]).any()\nFalse\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.chain","title":"<code>chain(other)</code>","text":"<p>Chain another iterable to the end of this iterator. The returned iterator will first yield all items of <code>self</code> and then yield all items of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[U]</code> <p>Iterable to chain to this one.</p> required <p>Returns:</p> Type Description <code>FluentIterator[Union[T, U]]</code> <p>Chained iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"We\", \"didn't\"]).chain([\"start\", \"the\", \"fire\"]).to_list()\n    [\"We\", \"didn't\", \"start\", \"the\", \"fire\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.count","title":"<code>count()</code>","text":"<p>Count the elements in this iterator. This will consume the iterator.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of items</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator(range(5)).count()\n    5\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.cycle","title":"<code>cycle()</code>","text":"<p>Make an infinite iterator by repeating the values from this one forever. It just goes round and round....</p>"},{"location":"api/#fluentiter.core.FluentIterator.cycle--notes","title":"Notes","text":"<p>Do not try to collect an infinite iterator</p> <p>Returns:</p> Type Description <code>CycleIterator[T]</code> <p>Infite cycling iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; never_ends = iterator(\"carousel\", \"wheels on the bus\").cycle()\n&gt;&gt;&gt; never_ends.next()\n    \"carousel\"\n&gt;&gt;&gt; never_ends.next()\n    \"wheels on the bus\"\n&gt;&gt;&gt; never_ends.next()\n    \"carousel\"\n&gt;&gt;&gt; never_ends.next()\n    \"wheels on the bus\"\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.enumerate","title":"<code>enumerate()</code>","text":"<p>Create an iterator which yields tuples of <code>(index, value)</code>.</p> <p>Returns:</p> Type Description <code>FluentIterator[Tuple[int, T]]</code> <p>Iterator of index, value tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"zero\", \"one\", \"two\"]).enumerate().to_list()\n    [(0, \"zero\"), (1, \"one\"), (2, \"two\")]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.filter","title":"<code>filter(func)</code>","text":"<p>Create a filtered iterator by applying a function to every element to evaluate whether or not it should be yielded.</p> <p>If the given function returns <code>True</code> the item will be yielded. If the function returns <code>False</code> the iterator will skip the item.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply as a filter.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Filtered iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([1.0, 1.5, 2.0]).filter(lambda x: x.is_integer()).to_list()\n    [1.0, 2.0]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.filter_map","title":"<code>filter_map(func)</code>","text":"<p>A combination of <code>.map</code> and <code>.filter</code>. Apply a given function to every element of the iterator and return the result only if it is not <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Optional[R]]</code> <p>Function to apply, returns <code>None</code> for elements to be filtered out.</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator of mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; (iterator([{\"food\": \"cake\"}, {\"beverage\": \"coffee\"}])\n&gt;&gt;&gt;     .filter_map(lambda x: x.get(\"food\", None))\n&gt;&gt;&gt;     .to_list()\n&gt;&gt;&gt; )\n    [\"cake\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.find","title":"<code>find(func)</code>","text":"<p>Find and return the first element for which the given function returns <code>True</code>.</p> <p>If no element matches or the iterator is empty, this raises <code>NotFoundError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to test elements</p> required <p>Returns:</p> Type Description <code>T</code> <p>First element which matches the predicate</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If no element matches</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).find(lambda x: x.startswith(\"w\"))\n    \"waldo\"\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.flat_map","title":"<code>flat_map(func, exclude=(str, bytes))</code>","text":"<p>Create an iterator which maps a function <code>func</code> across all elements, but also flattens the results if they are iterables.</p>"},{"location":"api/#fluentiter.core.FluentIterator.flat_map--notes","title":"Notes","text":"<p>By default <code>str</code> and <code>bytes</code> will not be flattened. You can control this via the <code>exclude</code> parameter</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Union[R, Iterable[R]]]</code> <p>Function to apply to all elements</p> required <code>exclude</code> <code>Tuple[Type, ...]</code> <p>Types which shall not be flattened, by default (str, bytes)</p> <code>(str, bytes)</code> <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator of flattened results</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dolphins = [\"So long\", \"and thanks\", \"for all the fish\"]\n&gt;&gt;&gt; iterator(dolphins).flat_map(lamba x: x.split()).to_list()\n    [\"So\", \"long\", \"and\", \"thanks\", \"for\", \"all\", \"the\", \"fish\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.flatten","title":"<code>flatten(exclude=(str, bytes))</code>","text":"<p>Make an iterator which which flattens all elements of this iterator.</p>"},{"location":"api/#fluentiter.core.FluentIterator.flatten--notes","title":"Notes","text":"<p>By default <code>str</code> and <code>bytes</code> will not be flattened. You can control this via the <code>exclude</code> parameter</p> <p>Parameters:</p> Name Type Description Default <code>exclude</code> <code>Tuple[Type, ...]</code> <p>Types which shall not be flattened, by default (str, bytes)</p> <code>(str, bytes)</code> <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator of flattened elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([(\"tire\", \"earth\"), [\"screen\"]]).flatten().to_list()\n    [\"tire\", \"earth\", \"screen\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.fold","title":"<code>fold(initial_value, func)</code>","text":"<p>Fold every element of this iterator into a single value by repeatedly applying <code>func</code>. The given function must takes two parameters, an accumulator <code>A</code> and an element of the iterator <code>T</code> and return the new accumulator <code>A</code> to be used on the next iteration.</p> <p>For an empty iterator this returns the initial value.</p>"},{"location":"api/#fluentiter.core.FluentIterator.fold--notes","title":"Notes","text":"<ul> <li>To return the elements instead of the accumulator, use <code>.scan</code>.</li> <li>To use the first element as <code>initial_value</code>, use <code>.reduce</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial_value</code> <code>A</code> <p>Initial value of the accumulator</p> required <code>func</code> <code>Callable[[S, T], A]</code> <p>Folding function</p> required <p>Returns:</p> Type Description <code>A</code> <p>Folded value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).fold(1, lambda a, x: a + len(x))\n    10\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.inspect","title":"<code>inspect(func)</code>","text":"<p>Return an iterator which applies <code>func</code> to every element, but still yields the original elements. This is useful if the function has some side effect like logging or printing.</p>"},{"location":"api/#fluentiter.core.FluentIterator.inspect--notes","title":"Notes","text":"<p>If the elements are mutable, <code>func</code> can still mutate them. Keep this in mind.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Any]</code> <p>Function to apply to every element.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator of the original elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lengths = []\n&gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).inspect(lambda x: lengths.append(len(x))).to_list()\n    [\"hot\", \"dog\", \"bun\"]\n&gt;&gt;&gt; lengths\n    [3, 3, 3]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.last","title":"<code>last()</code>","text":"<p>Return the last element in this iterator. If the iterator does not contain any elements, this returns None.</p> <p>This consumes the iterator.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Last element or None</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If the iterator has no elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"foo\", \"bar\", \"baz\"]).last()\n    \"baz\"\n&gt;&gt;&gt; iterator([]).last()\n    None\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.map","title":"<code>map(func)</code>","text":"<p>Apply a given function <code>func</code> to every element of the iterator, and return an iterator yielding the results of those function calls.</p> <p>Keep in mind, the function is not applied immediatly but as items are yielded from the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], R]</code> <p>Function to apply to every element.</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator yielding the function call results</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"don't\", \"panic\"]).map(lambda x: x.upper()).to_list()\n    [\"DON'T\", \"PANIC\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.map_while","title":"<code>map_while(func)</code>","text":"<p>A combination of <code>map</code> and <code>take_while</code>. Applies the given function to all elements of the iterator and yields the results. Once the function returns <code>None</code> the iterator will be exhausted and not yield any further items.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Union[R, None]]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator which yields mapped elements until <code>func</code> returns <code>None</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; me = [{\"state\": \"napping\"}, {\"state\": \"eating\"}, {\"state\": None}, {\"state\": \"napping\"}]\n&gt;&gt;&gt; iterator(me).map_while(lambda x: x.get(\"state\", None)).to_list()\n    [\"napping\", \"eating\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.max","title":"<code>max(key=None)</code>","text":"<p>Return the maximum element in this iterator.</p> <p>If a key is given, the results of <code>key(element)</code> will be compared instead of the elements themselves.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[Callable[T], Any]</code> <p>Key to use for comparison, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Maximum value</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If the iterator is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([42, 1337]).max()\n    1337\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.min","title":"<code>min(key=None)</code>","text":"<p>Return the minimum element in this iterator.</p> <p>If a key is given, the results of <code>key(element)</code> will be compared instead of the elements themselves.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[Callable[T], Any]</code> <p>Key to use for comparison, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Minimum value</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If the iterator is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([42, 1337]).min()\n    42\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.next","title":"<code>next()</code>","text":"<p>Advances the iterator and returns the next value.</p> <p>Will return <code>None</code> the iterator is exhausted</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Next element or None if iterator is exhausted</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If there is no next element</p>"},{"location":"api/#fluentiter.core.FluentIterator.nth","title":"<code>nth(index)</code>","text":"<p>Returns the nth element of the iterator. The index starts at <code>0</code>, i.e. <code>nth(0)</code> returns the first element. If the index is greater than or equal to the length of the iterator, this will return None.</p>"},{"location":"api/#fluentiter.core.FluentIterator.nth--notes","title":"Notes","text":"<p>This method consumes the iterator up to and including <code>index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to return</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If the iterator has less than <code>index + 1</code> items</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Value at the index or <code>None</code> if index is &gt;= iterator length</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"n\", \"t\", \"h\"]).nth(1)\n    \"t\"\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.partition","title":"<code>partition(func)</code>","text":"<p>Create two iterators from this one, by applying <code>func</code> to every element. All elements for which <code>func(element) == False</code> will become part of the first iterator, all those for which it returns <code>True</code> wil become part of the second iterator</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to sort elements into partitions</p> required <p>Returns:</p> Type Description <code>Tuple[FluentIterator[T], FluentIterator[T]]</code> <p>Two iterators, made from elements of this iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; odds, evens = iterator(range(10)).partition(lambda i: bool(i &amp; 1))\n&gt;&gt;&gt; odds.to_list()\n    [0, 2, 4, 6, 8]\n&gt;&gt;&gt; evens.to_list()\n    [1, 3, 5, 7, 9]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.peek","title":"<code>peek()</code>","text":"<p>Return the next element of the iterator, without advancing it.</p>"},{"location":"api/#fluentiter.core.FluentIterator.peek--notes","title":"Notes","text":"<p>Calling peek multiple times consecutively always returns the same element</p> <p>Returns:</p> Type Description <code>T</code> <p>The next element in the iterator</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If there is no next element to peek</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; myiter = iterator([\"p\", \"e\", \"e\", \"k\"])\n&gt;&gt;&gt; myiter.peek()\n    p\n&gt;&gt;&gt; myiter.peek()\n    p\n    myiter.to_list()\n    [\"p\", \"e\", \"e\", \"k\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.position","title":"<code>position(func)</code>","text":"<p>Find the index of the first element for which <code>func(element) == True</code>.</p> <p>If no item matches or the iterator is empty, returns <code>-1</code>, this behaviour aligns with Pythons <code>str.find</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Predicate to evaluta elements</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the first element matching the predicate or -1</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).position(lambda x: x == \"waldo\")\n    1\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.product","title":"<code>product()</code>","text":"<p>Return the product of all elements in this iterator.</p> <p>Returns:</p> Type Description <code>T</code> <p>The product of all elements</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If called on an empty iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([2, 3, 4]).product()\n    24\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.reduce","title":"<code>reduce(func)</code>","text":"<p>Reduce all elements into a single element by repeatedly applying <code>func</code>.</p> <p>The given function must take two parameters, the returned value of the previous iteration and the element of this iteration. For the first iteration this will be the first and second element of this iterator resepctively.</p>"},{"location":"api/#fluentiter.core.FluentIterator.reduce--notes","title":"Notes","text":"<ul> <li>To return the elements instead of the reduction, use <code>.scan</code>.</li> <li>To specify an <code>initial_value</code>, use <code>.fold</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, R], R]</code> <p>Reducing function</p> required <p>Returns:</p> Type Description <code>Union[T, R]</code> <p>Reduced element or first element of the iterator if it only has one.</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If called on an empty iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"reduce\", \"reuse\", \"recycle\"]).reduce(lambda x, y: f\"{x} {y}\")\n    \"reduce reuse recycle\"\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.rolling_window","title":"<code>rolling_window(size)</code>","text":"<p>Create an iterator of overlapping windows of size <code>size</code>.</p> <p>The windows will be yielded as tuples containing the original iterators elements</p>"},{"location":"api/#fluentiter.core.FluentIterator.rolling_window--notes","title":"Notes","text":"<p>Requires extra <code>more</code></p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the windows</p> required <p>Returns:</p> Type Description <code>RollingWindowIterator[T]</code> <p>An iterator of overlapping windows</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>size</code> is &lt;= 0</p> <p>Examples -------_</p> <p>iterator([2, 3, 4, 5]).rolling_window(2).to_list()     [(2, 3), (3, 4), (4, 5)]</p>"},{"location":"api/#fluentiter.core.FluentIterator.scan","title":"<code>scan(initial_state, func)</code>","text":"<p>Create an iterator which holds some internal state and applies some function using that state to every element, returning a tuple of the new state and a mapped element. The new state may then be used by the next iteration.</p>"},{"location":"api/#fluentiter.core.FluentIterator.scan--notes","title":"Notes","text":"<ul> <li> <p>To end the iteration, the function should raise <code>StopScan</code>.</p> </li> <li> <p>For the curious: The state is returned instead of mutated directly,   as many elements in Python (e.g. integers) are immutable and need to be reassigned.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>S</code> <p>Inital value of the state</p> required <code>func</code> <code>Callable[[S, T], Tuple[S, R]]</code> <p>Function to recieve the state and element as arguments</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Mapped iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator(range(10)).scan(\n&gt;&gt;&gt;     initial_state=(0, 0), func=lambda s, x: ((s[1], sum(s) or x), sum(s) or x)\n&gt;&gt;&gt; )\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.size_hint","title":"<code>size_hint()</code>","text":"<p>Get an estimate of the number of elements in this iterator or <code>None</code> if the value can not be estimated.</p> <p>Returns:</p> Type Description <code>Union[int, None]</code> <p>Length hint</p>"},{"location":"api/#fluentiter.core.FluentIterator.skip","title":"<code>skip(n)</code>","text":"<p>Skip the first <code>n</code> elements of this iterator. After <code>n</code> elements have been skipped, all subsequent elements are yielded.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to skip</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which skips its first <code>n</code> elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"do\", \"not\", \"pet\", \"the\", \"dog\"]).skip(2).to_list()\n    [\"pet\", \"the\", \"dog\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.skip_while","title":"<code>skip_while(func)</code>","text":"<p>Skip elements of this iterator by applying the given function to every element while it returns <code>True</code>. After the function has returned <code>False</code>, it will not be applied anymore and all subsequent items are yielded.</p> <p>The first element where the function returns <code>False</code> is also yielded.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>SkipWhileIterator[T]</code> <p>Iterator which skips elements while <code>func</code> returns <code>True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; week = [\"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n&gt;&gt;&gt; iterator(week).skip_while(lambda x: x != \"Saturday\").to_list()\n    [\"Saturday\", \"Sunday\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.step_by","title":"<code>step_by(size)</code>","text":"<p>Steps over the iterator with steps of size <code>size</code>. The first element of the iterator is always returned, subsequent items are only returned if there index is a multiple of <code>size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the step.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Stepping iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(2).to_list()\n    [1, 3, 5]\n&gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(1).to_list()\n    [1, 2, 3, 4, 5]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.sum","title":"<code>sum()</code>","text":"<p>Sum up all elements in this iterator</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>The sum of all elements or <code>None</code> if iterator is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([8, 14, 22]).sum()\n    42\n&gt;&gt;&gt; iterator([\"a\", \"b\", \"c\"]).sum()\n    \"abc\"\n&gt;&gt;&gt; iterator([]).sum()\n    None\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.take","title":"<code>take(n)</code>","text":"<p>Only yield the first <code>n</code> items of the iterator. After <code>n</code> elements have been yielded, the iterator will be exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of items to yield</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which yields the first <code>n</code> items</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; music = [\"on me\", \"me out\", \"that\"]\n&gt;&gt;&gt; iterator(music).take(2).to_list()\n    [\"on me\", \"me out\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.take_while","title":"<code>take_while(func)</code>","text":"<p>Apply a given function to every element of the iterator and only yield elements while this function returns <code>True</code>. Once the function returns <code>False</code> the iterator will be exhausted and not yield any further items.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>TakeWhileIterator[T]</code> <p>Iterator which yields elements until <code>func</code> returns <code>False</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; week = [\"Saturday, \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\n&gt;&gt;&gt; iterator(week).take_while(lambda x: x in {\"Saturday\", \"Sunday\"}).to_list()\n    [\"Monday\", \"Tuesday\", \"Wednesday\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.to_list","title":"<code>to_list()</code>","text":"<p>Collect this iterator into a list, completely consuming it. This is just a convenience method for <code>list()</code>.</p> <p>Returns:</p> Type Description <code>List[T]</code> <p>Collected iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bucket\", \"to-do\", \"wish\"]).to_list()\n    [\"bucket\", \"to-do\", \"wish\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.unzip","title":"<code>unzip()</code>","text":"<p>Unzip an iterator of tuples into two iterators, by building the first one from all first elements of each tuple, and the second from all other elements of the tuples.</p> <p>Returns:</p> Type Description <code>Tuple[FluentIterator[T], FluentIterator[U]]</code> <p>Two new iterators</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; morning, evening = iterator([(\"coffee\", \"beer\"), (\"pancake\", \"pizza\")]).unzip()\n&gt;&gt;&gt; morning.to_list()\n    [\"coffee\", \"pancake\"]\n&gt;&gt;&gt; evening.to_list()\n    [\"beer\", \"pizza\"]\n</code></pre>"},{"location":"api/#fluentiter.core.FluentIterator.zip","title":"<code>zip(other)</code>","text":"<p>Zip this iterator with another iterable, yielding 2-element tuples where the first element is an element from this iterator and the second element is an element of <code>other</code>.</p> <p>The iteration stops, as soon as one of the iterators is exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[U]</code> <p>An Iterable to zip this iterator with</p> required <p>Returns:</p> Type Description <code>FluentIterator[Tuple[T, U]]</code> <p>Zipped iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"ping\", \"ping\"]).zip([\"pong\", \"pong\"]).to_list()\n    [(\"ping\", \"pong\"), (\"ping\", \"pong\")]\n</code></pre>"}]}