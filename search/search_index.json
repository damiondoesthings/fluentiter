{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    fluentiterator.md\n</code></pre>"},{"location":"fluentiterator/","title":"FluentIterator API","text":"<p>             Bases: <code>Generic[T]</code>, <code>Iterator</code></p> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>class FluentIterator(Generic[T], Iterator):\n    def __init__(\n        self,\n        iterable: Iterable[T],\n        chained: Optional[\"FluentIterator[U]\"] = None,\n        step: int = 1,\n        skip_while: Optional[Callable[[T], bool]] = None,\n        take_while: Optional[Callable[[T], bool]] = None,\n    ) -&gt; None:\n        self._iterable = iter(iterable)\n        self._chained = chained\n        self._iter_len = _len(iterable)\n        self._chained_len = _len(chained)\n        self._step = step\n        self._skip_while = skip_while\n        self._take_while = take_while\n\n    def _true_next(self) -&gt; Union[T, _IterStop]:\n        try:\n            return next(self._iterable)\n        except StopIteration:\n            if self._chained is None:\n                return ITER_STOP\n            return next(self._chained)\n\n            # return self._chained.next()\n\n    def _advance_steps(self):\n        for _ in range(self._step - 1):\n            if self._true_next() is ITER_STOP:\n                return\n\n    def _next(self) -&gt; Union[T, _IterStop]:\n        skip = True\n        while skip:\n            elem = self._true_next()\n            if self._skip_while is None:\n                skip = False\n            else:\n                skip = self._skip_while(elem)\n        self._skip_while = None\n        if self._take_while is not None and not self._take_while(elem):\n            return ITER_STOP\n        self._advance_steps()\n        return elem\n\n    def next(self) -&gt; Optional[T]:\n\"\"\"\n        Advances the iterator and returns the next value.\n\n        Will return None the iterator is exhausted\n\n        Returns\n        -------\n        Optional[T]\n            Next element or None if iterator is exhausted\n        \"\"\"\n        elem = self._next()\n        return None if elem is ITER_STOP else elem\n\n    def size_hint(self) -&gt; Union[int, None]:\n\"\"\"\n        Get an estimate of the number of elements in\n        this iterator or `None` if the value can not be\n        estimated.\n\n        Returns\n        -------\n        Union[int, None]\n            Length hint\n        \"\"\"\n        hint = length_hint(self._iterable, 0)\n        if self._chained is not None:\n            hint += length_hint(self._chained, 0)\n        if hint == 0:\n            return None\n        return hint\n\n    def count(self) -&gt; int:\n\"\"\"\n        Count the elements in this iterator.\n        This will consume the iterator.\n\n        Returns\n        -------\n        int\n            Count of items\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator(range(5)).count()\n            5\n        \"\"\"\n        i = 0\n        for _ in self:\n            i += 1\n        return i\n\n    def last(self) -&gt; Optional[T]:\n\"\"\"\n        Return the last element in this iterator.\n        If the iterator does not contain any elements,\n        this returns None.\n\n        This consumes the iterator.\n\n        Returns\n        -------\n        Optional[T]\n            Last element or None\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"foo\", \"bar\", \"baz\"]).last()\n            \"baz\"\n        &gt;&gt;&gt; iterator([]).last()\n            None\n        \"\"\"\n        x = None\n        for y in self:\n            x = y\n        return x\n\n\n    def nth(self, index: int) -&gt; Optional[T]:\n\"\"\"\n        Returns the nth element of the iterator.\n        The index starts at `0`, i.e. `nth(0)` returns the first element.\n        If the index is greater than or equal to the lenght of the iterator, this will return None.\n\n        NOTE: This method consumes the iterator up to and including `index`.\n\n        Parameters\n        ----------\n        index : int\n            The index to return\n\n        Returns\n        -------\n        Optional[T]\n            Value at the index or `None` if index is &gt;= iterator length\n        \"\"\"\n        # TODO: factor out into advance_by\n        # TODO raise an IndexError instead\n        for _ in range(index):\n            if self._next() is ITER_STOP:\n                break\n        return self.next()\n\n    def step_by(self, size: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Steps over the iterator with steps of size `size`.\n        The first element of the iterator is always returned,\n        subsequent items are only returned if there index is a\n        multiple of `size`.\n\n\n        Parameters\n        ----------\n        size : int\n            Size of the step.\n\n        Returns\n        -------\n        FluentIterator[T]\n            Stepping iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(2).to_list()\n            [1, 3, 5]\n        &gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(1).to_list()\n            [1, 2, 3, 4, 5]\n        \"\"\"\n        # TODO: what does step_by(0) do?\n        return FluentIterator(self, step=size)\n\n    def chain(self, other: Iterable[U]) -&gt; \"FluentIterator[Union[T, U]]\":\n\"\"\"\n        Chain another iterable to the end of this iterator.\n        The returned iterator will first yield all items of `self` and then\n        yield all items of `other`.\n\n        Parameters\n        ----------\n        other : Iterable[U]\n            Iterable to chain to this one.\n\n        Returns\n        -------\n        FluentIterator[Union[T, U]]\n            Chained iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"We\", \"didn't\"]).chain([\"start\", \"the\", \"fire\"]).to_list()\n            [\"We\", \"didn't\", \"start\", \"the\", \"fire\"]\n        \"\"\"\n        return FluentIterator(self, chained=FluentIterator(other))\n\n    def zip(self, other: Iterable[U]) -&gt; \"FluentIterator[Tuple[T, U]]\":\n\"\"\"\n        Zip this iterator with another iterable, yielding 2-element tuples\n        where the first element is an element from this iterator and the\n        second element is an element of `other`.\n\n        The iteration stops, as soon as one of the iterators is exhausted.\n\n        Parameters\n        ----------\n        other : Iterable[U]\n            An Iterable to zip this iterator with\n\n        Returns\n        -------\n        FluentIterator[Tuple[T, U]]\n            Zipped iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"ping\", \"ping\"]).zip([\"pong\", \"pong\"]).to_list()\n            [(\"ping\", \"pong\"), (\"ping\", \"pong\")]\n        \"\"\"\n        return FluentIterator(zip(self, other))\n\n    def map(self, func: Callable[[T], R]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n        Apply a given function `func` to every element of the iterator,\n        and return an iterator yielding the results of those function calls.\n\n        Keep in mind, the function is not applied immediatly\n        but as items are yielded from the iterator.\n\n        Parameters\n        ----------\n        func : Callable[[T], R]\n            Function to apply to every element.\n\n        Returns\n        -------\n        FluentIterator[R]\n            Iterator yielding the function call results\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"don't\", \"panic\"]).map(lambda x: x.upper()).to_list()\n            [\"DON'T\", \"PANIC\"]\n        \"\"\"\n        return FluentIterator((func(x) for x in self))\n\n    def filter(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Create a filtered iterator by applying a function to every element\n        to evaluate whether or not it should be yielded.\n\n        If the given function returns `True` the item will be yielded.\n        If the function returns `False` the iterator will skip the item.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Function to apply as a filter.\n\n        Returns\n        -------\n        FluentIterator[T]\n            Filtered iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([1.0, 1.5, 2.0]).filter(lambda x: x.is_integer()).to_list()\n            [1.0, 2.0]\n        \"\"\"\n        filtered = (x for x in self if func(x))\n        return FluentIterator(filtered)\n\n    def filter_map(self, func: Callable[[T], Optional[R]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n        A combination of `.map` and `.filter`. Apply a given function to every\n        element of the iterator and return the result only if it is not `None`.\n\n        Parameters\n        ----------\n        func : Callable[[T], Optional[R]]\n            Function to apply, returns `None` for elements to be filtered out.\n\n        Returns\n        -------\n        FluentIterator[R]\n            Iterator of mapped values.\n\n        Examples\n        --------\n        &gt;&gt;&gt; (iterator([{\"food\": \"cake\"}, {\"beverage\": \"coffee\"}])\n        &gt;&gt;&gt;     .filter_map(lambda x: x.get(\"food\", None))\n        &gt;&gt;&gt;     .to_list()\n        &gt;&gt;&gt; )\n            [\"cake\"]\n        \"\"\"\n        return self.map(func=func).filter(lambda x: x is not None)\n\n    def enumerate(self) -&gt; \"FluentIterator[Tuple[int, T]]\":\n\"\"\"\n        Create an iterator which yields tuples of `(index, value)`.\n\n\n        Returns\n        -------\n        FluentIterator[Tuple[int, T]]\n            Iterator of index, value tuples\n\n        Examples\n        -------\n        &gt;&gt;&gt; iterator([\"zero\", \"one\", \"two\"]).enumerate().to_list()\n            [(0, \"zero\"), (1, \"one\"), (2, \"two\")]\n        \"\"\"\n        return FluentIterator(enumerate(self))\n\n    def peek(self) -&gt; T:\n\"\"\"\n        Return the next element of the iterator, **without** advancing it.\n\n        NOTE: Calling peek multiple times consecutively always returns\n        the same element\n\n        Returns\n        -------\n        T\n            The next element in the iterator\n\n        Raises\n        ------\n        StopIteration\n            If there is no next element to peek\n\n        Examples\n        --------\n        &gt;&gt;&gt; myiter = iterator([\"p\", \"e\", \"e\", \"k\"])\n        &gt;&gt;&gt; myiter.peek()\n            p\n        &gt;&gt;&gt; myiter.peek()\n            p\n            myiter.to_list()\n            [\"p\", \"e\", \"e\", \"k\"]\n        \"\"\"\n        # TODO: not sure if I actually want to implement this\n        # YES I DO\n        raise NotImplementedError\n\n    def skip_while(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Skip elements of this iterator by applying the given function to every\n        element while it returns `True`. After the function has returned `False`,\n        it will not be applied anymore and all subsequent items are yielded.\n\n        The first element where the function returns `False` is also yielded.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Function to apply to every element\n\n        Returns\n        -------\n        FluentIterator[T]\n            Iterator which skips elements while `func` returns `True`\n\n        Examples\n        --------\n        &gt;&gt;&gt; week = [\"Thursday\", \"Friday\", \"Saturday, \"Sunday\"]\n        &gt;&gt;&gt; iterator(week).skip_while(lambda x: x != \"Saturday\").to_list()\n            [\"Saturday\", \"Sunday\"]\n        \"\"\"\n        return FluentIterator(self, skip_while=func)\n\n    def take_while(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Apply a given function to every element of the iterator and only\n        yield elements while this function returns `True`. Once the function\n        returns `False` the iterator will be exhausted and not yield any\n        further items.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Function to apply to every element\n\n        Returns\n        -------\n        FluentIterator[T]\n            Iterator which yields elements until `func` returns `False`\n\n        Examples\n        -------\n        &gt;&gt;&gt; week = [\"Saturday, \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\n        &gt;&gt;&gt; iterator(week).take_while(lambda x: x in {\"Saturday\", \"Sunday\"}).to_list()\n            [\"Monday\", \"Tuesday\", \"Wednesday\"]\n        \"\"\"\n        return FluentIterator(self, take_while=func)\n\n    def map_while(self, func: Callable[[T], Union[R, None]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n        A combination of `map` and `take_while`. Applies the given function to\n        all elements of the iterator and yields the results. Once the function returns\n        `None` the iterator will be exhausted and not yield any further items.\n\n        Parameters\n        ----------\n        func : Callable[[T], Union[R, None]]\n            Function to apply to every element\n\n        Returns\n        -------\n        FluentIterator[R]\n            Iterator which yields mapped elements until `func` returns `None`\n\n        Examples\n        --------\n        &gt;&gt;&gt; me = [{\"state\": \"napping\"}, {\"state\": \"eating\"}, {\"state\": None}, {\"state\": \"napping\"}]\n        &gt;&gt;&gt; iterator(me).map_while(lambda x: x.get(\"state\", None)).to_list()\n            [\"napping\", \"eating\"]\n        \"\"\"\n        return self.map(func).take_while(lambda x: x is not None)\n\n    def skip(self, n: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Skip the first `n` elements of this iterator.\n        After `n` elements have been skipped, all subsequent elements\n        are yielded.\n\n        Parameters\n        ----------\n        n : int\n            Number of elements to skip\n\n        Returns\n        -------\n        FluentIterator[T]\n            Iterator which skips its first `n` elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"do\", \"not\", \"pet\", \"the\", \"dog\"]).skip(2).to_list()\n            [\"pet\", \"the\", \"dog\"]\n\n        \"\"\"\n        return self.skip_while(_SkipN(n))\n\n    def take(self, n: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Only yield the first `n` items of the iterator.\n        After `n` elements have been yielded, the iterator\n        will be exhausted.\n\n        Parameters\n        ----------\n        n : int\n            Number of items to yield\n\n        Returns\n        -------\n        FluentIterator[T]\n            Iterator which yields the first `n` items\n\n        Examples\n        --------\n        &gt;&gt;&gt; music = [\"on me\", \"me out\", \"that\"]\n        &gt;&gt;&gt; iterator(music).take(2).to_list()\n            [\"on me\", \"me out\"]\n        \"\"\"\n        return self.take_while(_SkipN(n))\n\n    S = TypeVar(\"S\")\n    def scan(self, initial_state: S, func: Callable[[S, T], Tuple[S, R]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n        Create an iterator which holds some internal state and applies some function\n        using that state to every element, returning a tuple of the new state\n        and a mapped element. The new state may then be used by the next iteration.\n\n        NOTE: To end the iteration, the function should raise `StopIteration`.\n\n        For the curious: The state is returned instead of mutated directly,\n        as many elements in Python (e.g. integers) are immutable and need to be reassigned.\n\n        Parameters\n        ----------\n        initial_state : S\n            Inital value of the state\n        func : Callable[[S, T], Tuple[S, R]]\n            Function to recieve the state and element as arguments\n\n        Returns\n        -------\n        FluentIterator[R]\n            Mapped iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator(range(7)).scan(0, lambda s, x: (x, s+x)).to_list()\n            [0, 1, 2, 3, 5, 8, 13]\n        \"\"\"\n        # TODO\n        # TODO add an example for this, because this is something\n        # which in python can only be done with a for-loop\n        raise NotImplementedError\n\n    def flat_map(\n        self: \"FluentIterator[Iterable[Inner]]\", func: Callable[[Inner], R]\n    ) -&gt; \"FluentIterator[R]\":\n\"\"\"\n        Create an iterator which maps a function `func` across all elements,\n        but also flattens the results if they are iterables.\n\n        Parameters\n        ----------\n        func : Callable[[Inner], R]\n            Function to apply to all elements\n\n        Returns\n        -------\n        FluentIterator[R]\n            Iterator of flattened results\n\n        Examples\n        --------\n        &gt;&gt;&gt; dolphins = [\"So long\", \"and thanks\", \"for all the fish\"]\n        &gt;&gt;&gt; iterator(dolphins).flat_map(lamba x: x.split()).to_list()\n            [\"So\", \"long\", \"and\", \"thanks\", \"for\", \"all\", \"the\", \"fish\"]\n        \"\"\"\n        return self.map(func).flatten()\n\n    def flatten(\n        self: \"FluentIterator[Union[Inner, Iterable[Inner]]]\",\n    ) -&gt; \"FluentIterator[Inner]\":\n\"\"\"\n        Make an iterator which which flattens all elements of this\n        iterator.\n\n        Returns\n        -------\n        FluentIterator[Inner]\n            Iterator of flattened elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([(\"tire\", \"earth\"), [\"screen\"]]).flatten().to_list()\n            [\"tire\", \"earth\", \"screen\"]\n        \"\"\"\n        return FluentIterator(iterable=_flatten(self))\n\n    def inspect(self, func: Callable[[T], Any]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Return an iterator which applies `func` to every element, but\n        still yields the original elements.\n        This is useful if the function has some side effect like logging\n        or printing.\n\n        NOTE: If the elements are mutable, `func` can still mutate them.\n        Keep this in mind.\n\n        Parameters\n        ----------\n        func : Callable[[T], Any]\n            Function to apply to every element.\n\n        Returns\n        -------\n        FluentIterator[T]\n            Iterator of the original elements.\n\n        Examples\n        --------\n        &gt;&gt;&gt; lengths = []\n        &gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).inspect(lambda x: lengths.append(len(x))).to_list()\n            [\"hot\", \"dog\", \"bun\"]\n        &gt;&gt;&gt; lengths\n            [3, 3, 3]\n        \"\"\"\n        _inspect = _Inspect(func=func)\n        return FluentIterator(iterable=(_inspect(x) for x in self))\n\n    def to_list(self) -&gt; List[T]:\n\"\"\"\n        Collect this iterator into a list, completely consuming it.\n        This is just a convinience method for `list()`.\n\n        Returns\n        -------\n        List[T]\n            Collected iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"bucket\", \"to-do\", \"whish\"]).to_list()\n            [\"bucket\", \"to-do\", \"whish\"]\n        \"\"\"\n        return list(self)\n\n    def partition(self, func: Callable[[T], bool]) -&gt; Tuple[\"FluentIterator[T]\", \"FluentIterator[T]\"]:\n\"\"\"\n        Create two iterators from this one, by applying `func` to every element.\n        All elements for which `func(element) == True` will become part of the\n        first iterator, all those for which it returns `False` wil become part\n        of the second iterator\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Function to apply to sort elements into partitions\n\n        Returns\n        -------\n        Tuple[\"FluentIterator[T]\", \"FluentIterator[T]\"]\n            Two iterators, made from elements of this iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; odds, evens = iterator(range(10)).partition(lambda i: bool(i &amp; 1))\n        &gt;&gt;&gt; odds.to_list()\n            [1, 3, 5, 7, 9]\n        &gt;&gt;&gt; evens.to_list()\n            [0, 2, 4, 6, 8]\n        \"\"\"\n        _partition = _Partition(self, func=func)\n        return FluentIterator(_partition.yield_a()), FluentIterator(_partition.yield_b())\n\n    A = TypeVar(\"A\")\n    def fold(self, initial_value: A, func: Callable[[A, T], S]) -&gt; A:\n\"\"\"\n        Fold every element of this iterator into a single value by repeatedly\n        applying `func`.\n        The given function must takes two parameters, an accumulator `A`\n        and an element of the iterator `T` and return the new accumulator `A` to be used\n        on the next iteration.\n\n        For an empty iterator this returns the initial value.\n\n        NOTE: To return the elements instead of the accumulator, use `.scan`.\n        NOTE: To use the first element as `initial_value`, use `.reduce`.\n\n        Parameters\n        ----------\n        initial_value: A\n            Initial value of the accumulator\n        func : Callable[[S, T], S]\n            Folding function\n\n        Returns\n        -------\n        S\n            Folded value\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).fold(0, lambda a, x: a + len(x))\n            9\n        \"\"\"\n        # TODO\n        raise NotImplementedError\n\n    def reduce(self, func: Callable[[Union[T, R]], R]) -&gt; Optional[R]:\n\"\"\"\n        Reduce all elements into a single element by repeatedly applying `func`.\n\n        The given function must take two parameters, the returned of the previous iteration\n        and the element of this iteration. For the first iteration this will be the\n        first and second element of this iterator resepctively.\n\n        NOTE: To return the elements instead of the reduction, use `.scan`.\n        NOTE: To specify the an `initial_value`, use `.fold`.\n\n        Parameters\n        ----------\n        func : Callable[[Union[T, R]], R]\n            Reducing function\n\n        Returns\n        -------\n        Optional[R]\n            Reduced element or \n\n        Raises\n        ------\n        EmptyIteratorError\n            If called on an empty iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"reduce\", \"reuse\", \"recycle\"]).reduce(lambda x, y: f\"{x} {y}\")\n            \"reduce reuse recycle\"        \n        \"\"\"\n        try:\n            return functools.reduce(func, self)\n        except TypeError:\n            raise EmptyIteratorError(\"Cannot reduce an empty iterator\")\n\n    def any(self, func: Callable[[T], bool] = bool) -&gt; bool:\n\"\"\"\n        Return `True` if the given function returns `True` for any element\n        of this iterator, otherwise return `False`.\n\n        For an empty iterator this is always `False`.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool], optional\n            Function to evaluate elements, by default bool\n\n        Returns\n        -------\n        bool\n            Whether any element of this iterator matches the predicate\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"one\", \"2\", \"three\"]).any(lambda x: x.is_digit())\n        True\n        &gt;&gt;&gt; iterator([]).any()\n        False\n        \"\"\"\n        # TODO\n        raise NotImplementedError\n\n    def find(self, func: Callable[[T], bool]) -&gt; T:\n\"\"\"\n        Find and return the first element for which the given function\n        returns `True`.\n\n        If no element matches or the iterator is empty, this raises\n        `NotFoundError`.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Function to test elements\n\n        Returns\n        -------\n        T\n            First element which matches the predicate\n\n        Raises\n        ------\n        NotFoundError\n            If no element matches\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).find(lambda x: x.startswith(\"w\"))\n            \"waldo\"\n        \"\"\"\n        # TODO\n        raise NotFoundError(\"No element matching the given predicate\")\n\n    def position(self, func: Callable[[T], bool]) -&gt; Union[int, Literal[-1]]:\n\"\"\"\n        Find the index of the first element for which `func(element) == True`.\n\n        If no item matches or the iterator is empty, this returns `-1`, this\n        behaviour aligns with Pythons `str.find`.\n\n        Parameters\n        ----------\n        func : Callable[[T], bool]\n            Predicate to evaluta elements\n\n        Returns\n        -------\n        int\n            Index of the first element matching the predicate or -1\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).position(lambda x: x == \"waldo\")\n            1\n        \"\"\"\n        # TODO\n        raise NotImplementedError\n\n    def max(self, key: Optional[Callable[T], Any] = None) -&gt; T:\n\"\"\"\n        Return the maximum element in this iterator.\n\n        If a key is given, the results of `key(element)` will\n        be compared instead of the elements themselves.\n\n        Parameters\n        ----------\n        key : Optional[Callable[T], Any], optional\n            Key to use for comparison, by default None\n\n        Returns\n        -------\n        T\n            Maximum value\n\n        Raises\n        ------\n        EmptyIteratorError\n            If the iterator is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([42, 1337]).max()\n            1337\n        \"\"\"\n        # TODO\n        raise EmptyIteratorError\n\n    def min(self, key: Optional[Callable[T], Any] = None) -&gt; T:\n\"\"\"\n        Return the minimum element in this iterator.\n\n        If a key is given, the results of `key(element)` will\n        be compared instead of the elements themselves.\n\n        Parameters\n        ----------\n        key : Optional[Callable[T], Any], optional\n            Key to use for comparison, by default None\n\n        Returns\n        -------\n        T\n            Minimum value\n\n        Raises\n        ------\n        EmptyIteratorError\n            If the iterator is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([42, 1337]).min()\n            42\n        \"\"\"\n        # TODO\n        raise EmptyIteratorError\n\n    def unzip(self: \"FluentIterator[Tuple[T, U]]\") -&gt; Tuple[\"FluentIterator[T]\", \"FluentIterator[U]\"]:\n\"\"\"\n        Unzip this iterator into two iterators, by building the first one from all first\n        elements of each tuple, and the second from all second elements of the tuples.\n\n        Returns\n        -------\n        Tuple[FluentIterator[T], FluentIterator[U]]\n            Two new iterators\n\n        Examples\n        --------\n        &gt;&gt;&gt; morning, evening = iterator([(\"coffee\", \"beer\"), (\"pancake\", \"pizza\")]).unzip()\n        &gt;&gt;&gt; morning.to_list()\n            [\"coffee\", \"pancake\"]\n        &gt;&gt;&gt; evening.to_list()\n            [\"beer\", \"pizza\"]\n        \"\"\"\n\n    def cycle(self) -&gt; \"FluentIterator[T]\":\n\"\"\"\n        Make an infinite iterator by repeating the values from this one forever.\n        It just goes round and round....\n\n        NOTE: Do not try to collect an infinite iterator\n\n        Returns\n        -------\n        FluentIterator[T]\n            Infite cycling iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; never_ends = iterator(\"carousel\", \"wheels on the bus\").cycle()\n        &gt;&gt;&gt; never_ends.next()\n            \"carousel\"\n        &gt;&gt;&gt; never_ends.next()\n            \"wheels on the bus\"\n        &gt;&gt;&gt; never_ends.next()\n            \"carousel\"\n        &gt;&gt;&gt; never_ends.next()\n            \"wheels on the bus\"\n        \"\"\"\n        # TODO\n        # TODO think about adding a is_infinite attribute to prevent collecting\n\n    def sum(self) -&gt; T:\n\"\"\"\n        Sum up all elements in this iterator\n\n        Returns\n        -------\n        T\n            The sum of all elements.\n\n        Raises\n        ------\n        EmptyIteratorError\n            If trying to sum an empty iterator\n\n        Example\n        &gt;&gt;&gt; iterator([8, 14, 22]).sum()\n            42\n        &gt;&gt;&gt; iterator([\"a\", \"b\", \"c\"]).sum()\n            \"abc\"\n        \"\"\"\n        # TODO\n        raise EmptyIteratorError\n\n    def product(self) -&gt; T:\n\"\"\"\n        Return the product of all elements in this iterator.\n\n        Returns\n        -------\n        T\n            The product of all elements\n\n        Raises\n        ------\n        EmptyIteratorError\n            If called on an empty iterator\n\n        Examples\n        --------\n        &gt;&gt;&gt; iterator([2, 3, 4]).product()\n            24        \n        \"\"\"\n        # TODO\n\n    def __iter__(self) -&gt; \"FluentIterator[T]\":\n        return self\n\n    def __next__(self) -&gt; T:\n        x = self._next()\n        if x is ITER_STOP:\n            raise StopIteration\n        return x\n\n    def __length_hint__(self) -&gt; int:\n        size_hint = self.size_hint()\n        if size_hint is not None:\n            return size_hint\n        return NotImplemented\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.any","title":"<code>any(func=bool)</code>","text":"<p>Return <code>True</code> if the given function returns <code>True</code> for any element of this iterator, otherwise return <code>False</code>.</p> <p>For an empty iterator this is always <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to evaluate elements, by default bool</p> <code>bool</code> <p>Returns:</p> Type Description <code>bool</code> <p>Whether any element of this iterator matches the predicate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"one\", \"2\", \"three\"]).any(lambda x: x.is_digit())\nTrue\n&gt;&gt;&gt; iterator([]).any()\nFalse\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def any(self, func: Callable[[T], bool] = bool) -&gt; bool:\n\"\"\"\n    Return `True` if the given function returns `True` for any element\n    of this iterator, otherwise return `False`.\n\n    For an empty iterator this is always `False`.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool], optional\n        Function to evaluate elements, by default bool\n\n    Returns\n    -------\n    bool\n        Whether any element of this iterator matches the predicate\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"one\", \"2\", \"three\"]).any(lambda x: x.is_digit())\n    True\n    &gt;&gt;&gt; iterator([]).any()\n    False\n    \"\"\"\n    # TODO\n    raise NotImplementedError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.chain","title":"<code>chain(other)</code>","text":"<p>Chain another iterable to the end of this iterator. The returned iterator will first yield all items of <code>self</code> and then yield all items of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[U]</code> <p>Iterable to chain to this one.</p> required <p>Returns:</p> Type Description <code>FluentIterator[Union[T, U]]</code> <p>Chained iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"We\", \"didn't\"]).chain([\"start\", \"the\", \"fire\"]).to_list()\n    [\"We\", \"didn't\", \"start\", \"the\", \"fire\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def chain(self, other: Iterable[U]) -&gt; \"FluentIterator[Union[T, U]]\":\n\"\"\"\n    Chain another iterable to the end of this iterator.\n    The returned iterator will first yield all items of `self` and then\n    yield all items of `other`.\n\n    Parameters\n    ----------\n    other : Iterable[U]\n        Iterable to chain to this one.\n\n    Returns\n    -------\n    FluentIterator[Union[T, U]]\n        Chained iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"We\", \"didn't\"]).chain([\"start\", \"the\", \"fire\"]).to_list()\n        [\"We\", \"didn't\", \"start\", \"the\", \"fire\"]\n    \"\"\"\n    return FluentIterator(self, chained=FluentIterator(other))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.count","title":"<code>count()</code>","text":"<p>Count the elements in this iterator. This will consume the iterator.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of items</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator(range(5)).count()\n    5\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def count(self) -&gt; int:\n\"\"\"\n    Count the elements in this iterator.\n    This will consume the iterator.\n\n    Returns\n    -------\n    int\n        Count of items\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator(range(5)).count()\n        5\n    \"\"\"\n    i = 0\n    for _ in self:\n        i += 1\n    return i\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.cycle","title":"<code>cycle()</code>","text":"<p>Make an infinite iterator by repeating the values from this one forever. It just goes round and round....</p> <p>NOTE: Do not try to collect an infinite iterator</p> <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Infite cycling iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; never_ends = iterator(\"carousel\", \"wheels on the bus\").cycle()\n&gt;&gt;&gt; never_ends.next()\n    \"carousel\"\n&gt;&gt;&gt; never_ends.next()\n    \"wheels on the bus\"\n&gt;&gt;&gt; never_ends.next()\n    \"carousel\"\n&gt;&gt;&gt; never_ends.next()\n    \"wheels on the bus\"\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def cycle(self) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Make an infinite iterator by repeating the values from this one forever.\n    It just goes round and round....\n\n    NOTE: Do not try to collect an infinite iterator\n\n    Returns\n    -------\n    FluentIterator[T]\n        Infite cycling iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; never_ends = iterator(\"carousel\", \"wheels on the bus\").cycle()\n    &gt;&gt;&gt; never_ends.next()\n        \"carousel\"\n    &gt;&gt;&gt; never_ends.next()\n        \"wheels on the bus\"\n    &gt;&gt;&gt; never_ends.next()\n        \"carousel\"\n    &gt;&gt;&gt; never_ends.next()\n        \"wheels on the bus\"\n    \"\"\"\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.enumerate","title":"<code>enumerate()</code>","text":"<p>Create an iterator which yields tuples of <code>(index, value)</code>.</p> <p>Returns:</p> Type Description <code>FluentIterator[Tuple[int, T]]</code> <p>Iterator of index, value tuples</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"zero\", \"one\", \"two\"]).enumerate().to_list()\n    [(0, \"zero\"), (1, \"one\"), (2, \"two\")]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def enumerate(self) -&gt; \"FluentIterator[Tuple[int, T]]\":\n\"\"\"\n    Create an iterator which yields tuples of `(index, value)`.\n\n\n    Returns\n    -------\n    FluentIterator[Tuple[int, T]]\n        Iterator of index, value tuples\n\n    Examples\n    -------\n    &gt;&gt;&gt; iterator([\"zero\", \"one\", \"two\"]).enumerate().to_list()\n        [(0, \"zero\"), (1, \"one\"), (2, \"two\")]\n    \"\"\"\n    return FluentIterator(enumerate(self))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.filter","title":"<code>filter(func)</code>","text":"<p>Create a filtered iterator by applying a function to every element to evaluate whether or not it should be yielded.</p> <p>If the given function returns <code>True</code> the item will be yielded. If the function returns <code>False</code> the iterator will skip the item.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply as a filter.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Filtered iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([1.0, 1.5, 2.0]).filter(lambda x: x.is_integer()).to_list()\n    [1.0, 2.0]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def filter(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Create a filtered iterator by applying a function to every element\n    to evaluate whether or not it should be yielded.\n\n    If the given function returns `True` the item will be yielded.\n    If the function returns `False` the iterator will skip the item.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Function to apply as a filter.\n\n    Returns\n    -------\n    FluentIterator[T]\n        Filtered iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([1.0, 1.5, 2.0]).filter(lambda x: x.is_integer()).to_list()\n        [1.0, 2.0]\n    \"\"\"\n    filtered = (x for x in self if func(x))\n    return FluentIterator(filtered)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.filter_map","title":"<code>filter_map(func)</code>","text":"<p>A combination of <code>.map</code> and <code>.filter</code>. Apply a given function to every element of the iterator and return the result only if it is not <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Optional[R]]</code> <p>Function to apply, returns <code>None</code> for elements to be filtered out.</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator of mapped values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; (iterator([{\"food\": \"cake\"}, {\"beverage\": \"coffee\"}])\n&gt;&gt;&gt;     .filter_map(lambda x: x.get(\"food\", None))\n&gt;&gt;&gt;     .to_list()\n&gt;&gt;&gt; )\n    [\"cake\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def filter_map(self, func: Callable[[T], Optional[R]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n    A combination of `.map` and `.filter`. Apply a given function to every\n    element of the iterator and return the result only if it is not `None`.\n\n    Parameters\n    ----------\n    func : Callable[[T], Optional[R]]\n        Function to apply, returns `None` for elements to be filtered out.\n\n    Returns\n    -------\n    FluentIterator[R]\n        Iterator of mapped values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; (iterator([{\"food\": \"cake\"}, {\"beverage\": \"coffee\"}])\n    &gt;&gt;&gt;     .filter_map(lambda x: x.get(\"food\", None))\n    &gt;&gt;&gt;     .to_list()\n    &gt;&gt;&gt; )\n        [\"cake\"]\n    \"\"\"\n    return self.map(func=func).filter(lambda x: x is not None)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.find","title":"<code>find(func)</code>","text":"<p>Find and return the first element for which the given function returns <code>True</code>.</p> <p>If no element matches or the iterator is empty, this raises <code>NotFoundError</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to test elements</p> required <p>Returns:</p> Type Description <code>T</code> <p>First element which matches the predicate</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If no element matches</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).find(lambda x: x.startswith(\"w\"))\n    \"waldo\"\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def find(self, func: Callable[[T], bool]) -&gt; T:\n\"\"\"\n    Find and return the first element for which the given function\n    returns `True`.\n\n    If no element matches or the iterator is empty, this raises\n    `NotFoundError`.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Function to test elements\n\n    Returns\n    -------\n    T\n        First element which matches the predicate\n\n    Raises\n    ------\n    NotFoundError\n        If no element matches\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).find(lambda x: x.startswith(\"w\"))\n        \"waldo\"\n    \"\"\"\n    # TODO\n    raise NotFoundError(\"No element matching the given predicate\")\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.flat_map","title":"<code>flat_map(func)</code>","text":"<p>Create an iterator which maps a function <code>func</code> across all elements, but also flattens the results if they are iterables.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Inner], R]</code> <p>Function to apply to all elements</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator of flattened results</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dolphins = [\"So long\", \"and thanks\", \"for all the fish\"]\n&gt;&gt;&gt; iterator(dolphins).flat_map(lamba x: x.split()).to_list()\n    [\"So\", \"long\", \"and\", \"thanks\", \"for\", \"all\", \"the\", \"fish\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def flat_map(\n    self: \"FluentIterator[Iterable[Inner]]\", func: Callable[[Inner], R]\n) -&gt; \"FluentIterator[R]\":\n\"\"\"\n    Create an iterator which maps a function `func` across all elements,\n    but also flattens the results if they are iterables.\n\n    Parameters\n    ----------\n    func : Callable[[Inner], R]\n        Function to apply to all elements\n\n    Returns\n    -------\n    FluentIterator[R]\n        Iterator of flattened results\n\n    Examples\n    --------\n    &gt;&gt;&gt; dolphins = [\"So long\", \"and thanks\", \"for all the fish\"]\n    &gt;&gt;&gt; iterator(dolphins).flat_map(lamba x: x.split()).to_list()\n        [\"So\", \"long\", \"and\", \"thanks\", \"for\", \"all\", \"the\", \"fish\"]\n    \"\"\"\n    return self.map(func).flatten()\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.flatten","title":"<code>flatten()</code>","text":"<p>Make an iterator which which flattens all elements of this iterator.</p> <p>Returns:</p> Type Description <code>FluentIterator[Inner]</code> <p>Iterator of flattened elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([(\"tire\", \"earth\"), [\"screen\"]]).flatten().to_list()\n    [\"tire\", \"earth\", \"screen\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def flatten(\n    self: \"FluentIterator[Union[Inner, Iterable[Inner]]]\",\n) -&gt; \"FluentIterator[Inner]\":\n\"\"\"\n    Make an iterator which which flattens all elements of this\n    iterator.\n\n    Returns\n    -------\n    FluentIterator[Inner]\n        Iterator of flattened elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([(\"tire\", \"earth\"), [\"screen\"]]).flatten().to_list()\n        [\"tire\", \"earth\", \"screen\"]\n    \"\"\"\n    return FluentIterator(iterable=_flatten(self))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.fold","title":"<code>fold(initial_value, func)</code>","text":"<p>Fold every element of this iterator into a single value by repeatedly applying <code>func</code>. The given function must takes two parameters, an accumulator <code>A</code> and an element of the iterator <code>T</code> and return the new accumulator <code>A</code> to be used on the next iteration.</p> <p>For an empty iterator this returns the initial value.</p> <p>NOTE: To return the elements instead of the accumulator, use <code>.scan</code>. NOTE: To use the first element as <code>initial_value</code>, use <code>.reduce</code>.</p> <p>Parameters:</p> Name Type Description Default <code>initial_value</code> <code>A</code> <p>Initial value of the accumulator</p> required <code>func</code> <code>Callable[[S, T], S]</code> <p>Folding function</p> required <p>Returns:</p> Type Description <code>S</code> <p>Folded value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).fold(0, lambda a, x: a + len(x))\n    9\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def fold(self, initial_value: A, func: Callable[[A, T], S]) -&gt; A:\n\"\"\"\n    Fold every element of this iterator into a single value by repeatedly\n    applying `func`.\n    The given function must takes two parameters, an accumulator `A`\n    and an element of the iterator `T` and return the new accumulator `A` to be used\n    on the next iteration.\n\n    For an empty iterator this returns the initial value.\n\n    NOTE: To return the elements instead of the accumulator, use `.scan`.\n    NOTE: To use the first element as `initial_value`, use `.reduce`.\n\n    Parameters\n    ----------\n    initial_value: A\n        Initial value of the accumulator\n    func : Callable[[S, T], S]\n        Folding function\n\n    Returns\n    -------\n    S\n        Folded value\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).fold(0, lambda a, x: a + len(x))\n        9\n    \"\"\"\n    # TODO\n    raise NotImplementedError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.inspect","title":"<code>inspect(func)</code>","text":"<p>Return an iterator which applies <code>func</code> to every element, but still yields the original elements. This is useful if the function has some side effect like logging or printing.</p> <p>NOTE: If the elements are mutable, <code>func</code> can still mutate them. Keep this in mind.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Any]</code> <p>Function to apply to every element.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator of the original elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lengths = []\n&gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).inspect(lambda x: lengths.append(len(x))).to_list()\n    [\"hot\", \"dog\", \"bun\"]\n&gt;&gt;&gt; lengths\n    [3, 3, 3]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def inspect(self, func: Callable[[T], Any]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Return an iterator which applies `func` to every element, but\n    still yields the original elements.\n    This is useful if the function has some side effect like logging\n    or printing.\n\n    NOTE: If the elements are mutable, `func` can still mutate them.\n    Keep this in mind.\n\n    Parameters\n    ----------\n    func : Callable[[T], Any]\n        Function to apply to every element.\n\n    Returns\n    -------\n    FluentIterator[T]\n        Iterator of the original elements.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lengths = []\n    &gt;&gt;&gt; iterator([\"hot\", \"dog\", \"bun\"]).inspect(lambda x: lengths.append(len(x))).to_list()\n        [\"hot\", \"dog\", \"bun\"]\n    &gt;&gt;&gt; lengths\n        [3, 3, 3]\n    \"\"\"\n    _inspect = _Inspect(func=func)\n    return FluentIterator(iterable=(_inspect(x) for x in self))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.last","title":"<code>last()</code>","text":"<p>Return the last element in this iterator. If the iterator does not contain any elements, this returns None.</p> <p>This consumes the iterator.</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Last element or None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"foo\", \"bar\", \"baz\"]).last()\n    \"baz\"\n&gt;&gt;&gt; iterator([]).last()\n    None\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def last(self) -&gt; Optional[T]:\n\"\"\"\n    Return the last element in this iterator.\n    If the iterator does not contain any elements,\n    this returns None.\n\n    This consumes the iterator.\n\n    Returns\n    -------\n    Optional[T]\n        Last element or None\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"foo\", \"bar\", \"baz\"]).last()\n        \"baz\"\n    &gt;&gt;&gt; iterator([]).last()\n        None\n    \"\"\"\n    x = None\n    for y in self:\n        x = y\n    return x\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.map","title":"<code>map(func)</code>","text":"<p>Apply a given function <code>func</code> to every element of the iterator, and return an iterator yielding the results of those function calls.</p> <p>Keep in mind, the function is not applied immediatly but as items are yielded from the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], R]</code> <p>Function to apply to every element.</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator yielding the function call results</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"don't\", \"panic\"]).map(lambda x: x.upper()).to_list()\n    [\"DON'T\", \"PANIC\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def map(self, func: Callable[[T], R]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n    Apply a given function `func` to every element of the iterator,\n    and return an iterator yielding the results of those function calls.\n\n    Keep in mind, the function is not applied immediatly\n    but as items are yielded from the iterator.\n\n    Parameters\n    ----------\n    func : Callable[[T], R]\n        Function to apply to every element.\n\n    Returns\n    -------\n    FluentIterator[R]\n        Iterator yielding the function call results\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"don't\", \"panic\"]).map(lambda x: x.upper()).to_list()\n        [\"DON'T\", \"PANIC\"]\n    \"\"\"\n    return FluentIterator((func(x) for x in self))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.map_while","title":"<code>map_while(func)</code>","text":"<p>A combination of <code>map</code> and <code>take_while</code>. Applies the given function to all elements of the iterator and yields the results. Once the function returns <code>None</code> the iterator will be exhausted and not yield any further items.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Union[R, None]]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Iterator which yields mapped elements until <code>func</code> returns <code>None</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; me = [{\"state\": \"napping\"}, {\"state\": \"eating\"}, {\"state\": None}, {\"state\": \"napping\"}]\n&gt;&gt;&gt; iterator(me).map_while(lambda x: x.get(\"state\", None)).to_list()\n    [\"napping\", \"eating\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def map_while(self, func: Callable[[T], Union[R, None]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n    A combination of `map` and `take_while`. Applies the given function to\n    all elements of the iterator and yields the results. Once the function returns\n    `None` the iterator will be exhausted and not yield any further items.\n\n    Parameters\n    ----------\n    func : Callable[[T], Union[R, None]]\n        Function to apply to every element\n\n    Returns\n    -------\n    FluentIterator[R]\n        Iterator which yields mapped elements until `func` returns `None`\n\n    Examples\n    --------\n    &gt;&gt;&gt; me = [{\"state\": \"napping\"}, {\"state\": \"eating\"}, {\"state\": None}, {\"state\": \"napping\"}]\n    &gt;&gt;&gt; iterator(me).map_while(lambda x: x.get(\"state\", None)).to_list()\n        [\"napping\", \"eating\"]\n    \"\"\"\n    return self.map(func).take_while(lambda x: x is not None)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.max","title":"<code>max(key=None)</code>","text":"<p>Return the maximum element in this iterator.</p> <p>If a key is given, the results of <code>key(element)</code> will be compared instead of the elements themselves.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[Callable[T], Any]</code> <p>Key to use for comparison, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Maximum value</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If the iterator is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([42, 1337]).max()\n    1337\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def max(self, key: Optional[Callable[T], Any] = None) -&gt; T:\n\"\"\"\n    Return the maximum element in this iterator.\n\n    If a key is given, the results of `key(element)` will\n    be compared instead of the elements themselves.\n\n    Parameters\n    ----------\n    key : Optional[Callable[T], Any], optional\n        Key to use for comparison, by default None\n\n    Returns\n    -------\n    T\n        Maximum value\n\n    Raises\n    ------\n    EmptyIteratorError\n        If the iterator is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([42, 1337]).max()\n        1337\n    \"\"\"\n    # TODO\n    raise EmptyIteratorError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.min","title":"<code>min(key=None)</code>","text":"<p>Return the minimum element in this iterator.</p> <p>If a key is given, the results of <code>key(element)</code> will be compared instead of the elements themselves.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Optional[Callable[T], Any]</code> <p>Key to use for comparison, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Minimum value</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If the iterator is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([42, 1337]).min()\n    42\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def min(self, key: Optional[Callable[T], Any] = None) -&gt; T:\n\"\"\"\n    Return the minimum element in this iterator.\n\n    If a key is given, the results of `key(element)` will\n    be compared instead of the elements themselves.\n\n    Parameters\n    ----------\n    key : Optional[Callable[T], Any], optional\n        Key to use for comparison, by default None\n\n    Returns\n    -------\n    T\n        Minimum value\n\n    Raises\n    ------\n    EmptyIteratorError\n        If the iterator is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([42, 1337]).min()\n        42\n    \"\"\"\n    # TODO\n    raise EmptyIteratorError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.next","title":"<code>next()</code>","text":"<p>Advances the iterator and returns the next value.</p> <p>Will return None the iterator is exhausted</p> <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Next element or None if iterator is exhausted</p> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def next(self) -&gt; Optional[T]:\n\"\"\"\n    Advances the iterator and returns the next value.\n\n    Will return None the iterator is exhausted\n\n    Returns\n    -------\n    Optional[T]\n        Next element or None if iterator is exhausted\n    \"\"\"\n    elem = self._next()\n    return None if elem is ITER_STOP else elem\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.nth","title":"<code>nth(index)</code>","text":"<p>Returns the nth element of the iterator. The index starts at <code>0</code>, i.e. <code>nth(0)</code> returns the first element. If the index is greater than or equal to the lenght of the iterator, this will return None.</p> <p>NOTE: This method consumes the iterator up to and including <code>index</code>.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index to return</p> required <p>Returns:</p> Type Description <code>Optional[T]</code> <p>Value at the index or <code>None</code> if index is &gt;= iterator length</p> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def nth(self, index: int) -&gt; Optional[T]:\n\"\"\"\n    Returns the nth element of the iterator.\n    The index starts at `0`, i.e. `nth(0)` returns the first element.\n    If the index is greater than or equal to the lenght of the iterator, this will return None.\n\n    NOTE: This method consumes the iterator up to and including `index`.\n\n    Parameters\n    ----------\n    index : int\n        The index to return\n\n    Returns\n    -------\n    Optional[T]\n        Value at the index or `None` if index is &gt;= iterator length\n    \"\"\"\n    # TODO: factor out into advance_by\n    # TODO raise an IndexError instead\n    for _ in range(index):\n        if self._next() is ITER_STOP:\n            break\n    return self.next()\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.partition","title":"<code>partition(func)</code>","text":"<p>Create two iterators from this one, by applying <code>func</code> to every element. All elements for which <code>func(element) == True</code> will become part of the first iterator, all those for which it returns <code>False</code> wil become part of the second iterator</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to sort elements into partitions</p> required <p>Returns:</p> Type Description <code>Tuple[FluentIterator[T], FluentIterator[T]]</code> <p>Two iterators, made from elements of this iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; odds, evens = iterator(range(10)).partition(lambda i: bool(i &amp; 1))\n&gt;&gt;&gt; odds.to_list()\n    [1, 3, 5, 7, 9]\n&gt;&gt;&gt; evens.to_list()\n    [0, 2, 4, 6, 8]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def partition(self, func: Callable[[T], bool]) -&gt; Tuple[\"FluentIterator[T]\", \"FluentIterator[T]\"]:\n\"\"\"\n    Create two iterators from this one, by applying `func` to every element.\n    All elements for which `func(element) == True` will become part of the\n    first iterator, all those for which it returns `False` wil become part\n    of the second iterator\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Function to apply to sort elements into partitions\n\n    Returns\n    -------\n    Tuple[\"FluentIterator[T]\", \"FluentIterator[T]\"]\n        Two iterators, made from elements of this iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; odds, evens = iterator(range(10)).partition(lambda i: bool(i &amp; 1))\n    &gt;&gt;&gt; odds.to_list()\n        [1, 3, 5, 7, 9]\n    &gt;&gt;&gt; evens.to_list()\n        [0, 2, 4, 6, 8]\n    \"\"\"\n    _partition = _Partition(self, func=func)\n    return FluentIterator(_partition.yield_a()), FluentIterator(_partition.yield_b())\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.peek","title":"<code>peek()</code>","text":"<p>Return the next element of the iterator, without advancing it.</p> <p>NOTE: Calling peek multiple times consecutively always returns the same element</p> <p>Returns:</p> Type Description <code>T</code> <p>The next element in the iterator</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If there is no next element to peek</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; myiter = iterator([\"p\", \"e\", \"e\", \"k\"])\n&gt;&gt;&gt; myiter.peek()\n    p\n&gt;&gt;&gt; myiter.peek()\n    p\n    myiter.to_list()\n    [\"p\", \"e\", \"e\", \"k\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def peek(self) -&gt; T:\n\"\"\"\n    Return the next element of the iterator, **without** advancing it.\n\n    NOTE: Calling peek multiple times consecutively always returns\n    the same element\n\n    Returns\n    -------\n    T\n        The next element in the iterator\n\n    Raises\n    ------\n    StopIteration\n        If there is no next element to peek\n\n    Examples\n    --------\n    &gt;&gt;&gt; myiter = iterator([\"p\", \"e\", \"e\", \"k\"])\n    &gt;&gt;&gt; myiter.peek()\n        p\n    &gt;&gt;&gt; myiter.peek()\n        p\n        myiter.to_list()\n        [\"p\", \"e\", \"e\", \"k\"]\n    \"\"\"\n    # TODO: not sure if I actually want to implement this\n    # YES I DO\n    raise NotImplementedError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.position","title":"<code>position(func)</code>","text":"<p>Find the index of the first element for which <code>func(element) == True</code>.</p> <p>If no item matches or the iterator is empty, this returns <code>-1</code>, this behaviour aligns with Pythons <code>str.find</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Predicate to evaluta elements</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the first element matching the predicate or -1</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).position(lambda x: x == \"waldo\")\n    1\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def position(self, func: Callable[[T], bool]) -&gt; Union[int, Literal[-1]]:\n\"\"\"\n    Find the index of the first element for which `func(element) == True`.\n\n    If no item matches or the iterator is empty, this returns `-1`, this\n    behaviour aligns with Pythons `str.find`.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Predicate to evaluta elements\n\n    Returns\n    -------\n    int\n        Index of the first element matching the predicate or -1\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"bert\", \"waldo\", \"ernie\"]).position(lambda x: x == \"waldo\")\n        1\n    \"\"\"\n    # TODO\n    raise NotImplementedError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.product","title":"<code>product()</code>","text":"<p>Return the product of all elements in this iterator.</p> <p>Returns:</p> Type Description <code>T</code> <p>The product of all elements</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If called on an empty iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([2, 3, 4]).product()\n    24\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def product(self) -&gt; T:\n\"\"\"\n    Return the product of all elements in this iterator.\n\n    Returns\n    -------\n    T\n        The product of all elements\n\n    Raises\n    ------\n    EmptyIteratorError\n        If called on an empty iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([2, 3, 4]).product()\n        24        \n    \"\"\"\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.reduce","title":"<code>reduce(func)</code>","text":"<p>Reduce all elements into a single element by repeatedly applying <code>func</code>.</p> <p>The given function must take two parameters, the returned of the previous iteration and the element of this iteration. For the first iteration this will be the first and second element of this iterator resepctively.</p> <p>NOTE: To return the elements instead of the reduction, use <code>.scan</code>. NOTE: To specify the an <code>initial_value</code>, use <code>.fold</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Union[T, R]], R]</code> <p>Reducing function</p> required <p>Returns:</p> Type Description <code>Optional[R]</code> <p>Reduced element or </p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If called on an empty iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"reduce\", \"reuse\", \"recycle\"]).reduce(lambda x, y: f\"{x} {y}\")\n    \"reduce reuse recycle\"\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def reduce(self, func: Callable[[Union[T, R]], R]) -&gt; Optional[R]:\n\"\"\"\n    Reduce all elements into a single element by repeatedly applying `func`.\n\n    The given function must take two parameters, the returned of the previous iteration\n    and the element of this iteration. For the first iteration this will be the\n    first and second element of this iterator resepctively.\n\n    NOTE: To return the elements instead of the reduction, use `.scan`.\n    NOTE: To specify the an `initial_value`, use `.fold`.\n\n    Parameters\n    ----------\n    func : Callable[[Union[T, R]], R]\n        Reducing function\n\n    Returns\n    -------\n    Optional[R]\n        Reduced element or \n\n    Raises\n    ------\n    EmptyIteratorError\n        If called on an empty iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"reduce\", \"reuse\", \"recycle\"]).reduce(lambda x, y: f\"{x} {y}\")\n        \"reduce reuse recycle\"        \n    \"\"\"\n    try:\n        return functools.reduce(func, self)\n    except TypeError:\n        raise EmptyIteratorError(\"Cannot reduce an empty iterator\")\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.scan","title":"<code>scan(initial_state, func)</code>","text":"<p>Create an iterator which holds some internal state and applies some function using that state to every element, returning a tuple of the new state and a mapped element. The new state may then be used by the next iteration.</p> <p>NOTE: To end the iteration, the function should raise <code>StopIteration</code>.</p> <p>For the curious: The state is returned instead of mutated directly, as many elements in Python (e.g. integers) are immutable and need to be reassigned.</p> <p>Parameters:</p> Name Type Description Default <code>initial_state</code> <code>S</code> <p>Inital value of the state</p> required <code>func</code> <code>Callable[[S, T], Tuple[S, R]]</code> <p>Function to recieve the state and element as arguments</p> required <p>Returns:</p> Type Description <code>FluentIterator[R]</code> <p>Mapped iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator(range(7)).scan(0, lambda s, x: (x, s+x)).to_list()\n    [0, 1, 2, 3, 5, 8, 13]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def scan(self, initial_state: S, func: Callable[[S, T], Tuple[S, R]]) -&gt; \"FluentIterator[R]\":\n\"\"\"\n    Create an iterator which holds some internal state and applies some function\n    using that state to every element, returning a tuple of the new state\n    and a mapped element. The new state may then be used by the next iteration.\n\n    NOTE: To end the iteration, the function should raise `StopIteration`.\n\n    For the curious: The state is returned instead of mutated directly,\n    as many elements in Python (e.g. integers) are immutable and need to be reassigned.\n\n    Parameters\n    ----------\n    initial_state : S\n        Inital value of the state\n    func : Callable[[S, T], Tuple[S, R]]\n        Function to recieve the state and element as arguments\n\n    Returns\n    -------\n    FluentIterator[R]\n        Mapped iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator(range(7)).scan(0, lambda s, x: (x, s+x)).to_list()\n        [0, 1, 2, 3, 5, 8, 13]\n    \"\"\"\n    # TODO\n    # TODO add an example for this, because this is something\n    # which in python can only be done with a for-loop\n    raise NotImplementedError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.size_hint","title":"<code>size_hint()</code>","text":"<p>Get an estimate of the number of elements in this iterator or <code>None</code> if the value can not be estimated.</p> <p>Returns:</p> Type Description <code>Union[int, None]</code> <p>Length hint</p> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def size_hint(self) -&gt; Union[int, None]:\n\"\"\"\n    Get an estimate of the number of elements in\n    this iterator or `None` if the value can not be\n    estimated.\n\n    Returns\n    -------\n    Union[int, None]\n        Length hint\n    \"\"\"\n    hint = length_hint(self._iterable, 0)\n    if self._chained is not None:\n        hint += length_hint(self._chained, 0)\n    if hint == 0:\n        return None\n    return hint\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.skip","title":"<code>skip(n)</code>","text":"<p>Skip the first <code>n</code> elements of this iterator. After <code>n</code> elements have been skipped, all subsequent elements are yielded.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to skip</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which skips its first <code>n</code> elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"do\", \"not\", \"pet\", \"the\", \"dog\"]).skip(2).to_list()\n    [\"pet\", \"the\", \"dog\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def skip(self, n: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Skip the first `n` elements of this iterator.\n    After `n` elements have been skipped, all subsequent elements\n    are yielded.\n\n    Parameters\n    ----------\n    n : int\n        Number of elements to skip\n\n    Returns\n    -------\n    FluentIterator[T]\n        Iterator which skips its first `n` elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"do\", \"not\", \"pet\", \"the\", \"dog\"]).skip(2).to_list()\n        [\"pet\", \"the\", \"dog\"]\n\n    \"\"\"\n    return self.skip_while(_SkipN(n))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.skip_while","title":"<code>skip_while(func)</code>","text":"<p>Skip elements of this iterator by applying the given function to every element while it returns <code>True</code>. After the function has returned <code>False</code>, it will not be applied anymore and all subsequent items are yielded.</p> <p>The first element where the function returns <code>False</code> is also yielded.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which skips elements while <code>func</code> returns <code>True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; week = [\"Thursday\", \"Friday\", \"Saturday, \"Sunday\"]\n&gt;&gt;&gt; iterator(week).skip_while(lambda x: x != \"Saturday\").to_list()\n    [\"Saturday\", \"Sunday\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def skip_while(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Skip elements of this iterator by applying the given function to every\n    element while it returns `True`. After the function has returned `False`,\n    it will not be applied anymore and all subsequent items are yielded.\n\n    The first element where the function returns `False` is also yielded.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Function to apply to every element\n\n    Returns\n    -------\n    FluentIterator[T]\n        Iterator which skips elements while `func` returns `True`\n\n    Examples\n    --------\n    &gt;&gt;&gt; week = [\"Thursday\", \"Friday\", \"Saturday, \"Sunday\"]\n    &gt;&gt;&gt; iterator(week).skip_while(lambda x: x != \"Saturday\").to_list()\n        [\"Saturday\", \"Sunday\"]\n    \"\"\"\n    return FluentIterator(self, skip_while=func)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.step_by","title":"<code>step_by(size)</code>","text":"<p>Steps over the iterator with steps of size <code>size</code>. The first element of the iterator is always returned, subsequent items are only returned if there index is a multiple of <code>size</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the step.</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Stepping iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(2).to_list()\n    [1, 3, 5]\n&gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(1).to_list()\n    [1, 2, 3, 4, 5]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def step_by(self, size: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Steps over the iterator with steps of size `size`.\n    The first element of the iterator is always returned,\n    subsequent items are only returned if there index is a\n    multiple of `size`.\n\n\n    Parameters\n    ----------\n    size : int\n        Size of the step.\n\n    Returns\n    -------\n    FluentIterator[T]\n        Stepping iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(2).to_list()\n        [1, 3, 5]\n    &gt;&gt;&gt; iterator([1,2,3,4,5]).step_by(1).to_list()\n        [1, 2, 3, 4, 5]\n    \"\"\"\n    # TODO: what does step_by(0) do?\n    return FluentIterator(self, step=size)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.sum","title":"<code>sum()</code>","text":"<p>Sum up all elements in this iterator</p> <p>Returns:</p> Type Description <code>T</code> <p>The sum of all elements.</p> <p>Raises:</p> Type Description <code>EmptyIteratorError</code> <p>If trying to sum an empty iterator</p> <p>Example</p> <p>iterator([8, 14, 22]).sum()     42 iterator([\"a\", \"b\", \"c\"]).sum()     \"abc\"</p> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def sum(self) -&gt; T:\n\"\"\"\n    Sum up all elements in this iterator\n\n    Returns\n    -------\n    T\n        The sum of all elements.\n\n    Raises\n    ------\n    EmptyIteratorError\n        If trying to sum an empty iterator\n\n    Example\n    &gt;&gt;&gt; iterator([8, 14, 22]).sum()\n        42\n    &gt;&gt;&gt; iterator([\"a\", \"b\", \"c\"]).sum()\n        \"abc\"\n    \"\"\"\n    # TODO\n    raise EmptyIteratorError\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.take","title":"<code>take(n)</code>","text":"<p>Only yield the first <code>n</code> items of the iterator. After <code>n</code> elements have been yielded, the iterator will be exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of items to yield</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which yields the first <code>n</code> items</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; music = [\"on me\", \"me out\", \"that\"]\n&gt;&gt;&gt; iterator(music).take(2).to_list()\n    [\"on me\", \"me out\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def take(self, n: int) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Only yield the first `n` items of the iterator.\n    After `n` elements have been yielded, the iterator\n    will be exhausted.\n\n    Parameters\n    ----------\n    n : int\n        Number of items to yield\n\n    Returns\n    -------\n    FluentIterator[T]\n        Iterator which yields the first `n` items\n\n    Examples\n    --------\n    &gt;&gt;&gt; music = [\"on me\", \"me out\", \"that\"]\n    &gt;&gt;&gt; iterator(music).take(2).to_list()\n        [\"on me\", \"me out\"]\n    \"\"\"\n    return self.take_while(_SkipN(n))\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.take_while","title":"<code>take_while(func)</code>","text":"<p>Apply a given function to every element of the iterator and only yield elements while this function returns <code>True</code>. Once the function returns <code>False</code> the iterator will be exhausted and not yield any further items.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to apply to every element</p> required <p>Returns:</p> Type Description <code>FluentIterator[T]</code> <p>Iterator which yields elements until <code>func</code> returns <code>False</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; week = [\"Saturday, \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\n&gt;&gt;&gt; iterator(week).take_while(lambda x: x in {\"Saturday\", \"Sunday\"}).to_list()\n    [\"Monday\", \"Tuesday\", \"Wednesday\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def take_while(self, func: Callable[[T], bool]) -&gt; \"FluentIterator[T]\":\n\"\"\"\n    Apply a given function to every element of the iterator and only\n    yield elements while this function returns `True`. Once the function\n    returns `False` the iterator will be exhausted and not yield any\n    further items.\n\n    Parameters\n    ----------\n    func : Callable[[T], bool]\n        Function to apply to every element\n\n    Returns\n    -------\n    FluentIterator[T]\n        Iterator which yields elements until `func` returns `False`\n\n    Examples\n    -------\n    &gt;&gt;&gt; week = [\"Saturday, \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\"]\n    &gt;&gt;&gt; iterator(week).take_while(lambda x: x in {\"Saturday\", \"Sunday\"}).to_list()\n        [\"Monday\", \"Tuesday\", \"Wednesday\"]\n    \"\"\"\n    return FluentIterator(self, take_while=func)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.to_list","title":"<code>to_list()</code>","text":"<p>Collect this iterator into a list, completely consuming it. This is just a convinience method for <code>list()</code>.</p> <p>Returns:</p> Type Description <code>List[T]</code> <p>Collected iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"bucket\", \"to-do\", \"whish\"]).to_list()\n    [\"bucket\", \"to-do\", \"whish\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def to_list(self) -&gt; List[T]:\n\"\"\"\n    Collect this iterator into a list, completely consuming it.\n    This is just a convinience method for `list()`.\n\n    Returns\n    -------\n    List[T]\n        Collected iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"bucket\", \"to-do\", \"whish\"]).to_list()\n        [\"bucket\", \"to-do\", \"whish\"]\n    \"\"\"\n    return list(self)\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.unzip","title":"<code>unzip()</code>","text":"<p>Unzip this iterator into two iterators, by building the first one from all first elements of each tuple, and the second from all second elements of the tuples.</p> <p>Returns:</p> Type Description <code>Tuple[FluentIterator[T], FluentIterator[U]]</code> <p>Two new iterators</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; morning, evening = iterator([(\"coffee\", \"beer\"), (\"pancake\", \"pizza\")]).unzip()\n&gt;&gt;&gt; morning.to_list()\n    [\"coffee\", \"pancake\"]\n&gt;&gt;&gt; evening.to_list()\n    [\"beer\", \"pizza\"]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def unzip(self: \"FluentIterator[Tuple[T, U]]\") -&gt; Tuple[\"FluentIterator[T]\", \"FluentIterator[U]\"]:\n\"\"\"\n    Unzip this iterator into two iterators, by building the first one from all first\n    elements of each tuple, and the second from all second elements of the tuples.\n\n    Returns\n    -------\n    Tuple[FluentIterator[T], FluentIterator[U]]\n        Two new iterators\n\n    Examples\n    --------\n    &gt;&gt;&gt; morning, evening = iterator([(\"coffee\", \"beer\"), (\"pancake\", \"pizza\")]).unzip()\n    &gt;&gt;&gt; morning.to_list()\n        [\"coffee\", \"pancake\"]\n    &gt;&gt;&gt; evening.to_list()\n        [\"beer\", \"pizza\"]\n    \"\"\"\n</code></pre>"},{"location":"fluentiterator/#fluentiter.fluentiterator.FluentIterator.zip","title":"<code>zip(other)</code>","text":"<p>Zip this iterator with another iterable, yielding 2-element tuples where the first element is an element from this iterator and the second element is an element of <code>other</code>.</p> <p>The iteration stops, as soon as one of the iterators is exhausted.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[U]</code> <p>An Iterable to zip this iterator with</p> required <p>Returns:</p> Type Description <code>FluentIterator[Tuple[T, U]]</code> <p>Zipped iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iterator([\"ping\", \"ping\"]).zip([\"pong\", \"pong\"]).to_list()\n    [(\"ping\", \"pong\"), (\"ping\", \"pong\")]\n</code></pre> Source code in <code>fluentiter/fluentiterator.py</code> <pre><code>def zip(self, other: Iterable[U]) -&gt; \"FluentIterator[Tuple[T, U]]\":\n\"\"\"\n    Zip this iterator with another iterable, yielding 2-element tuples\n    where the first element is an element from this iterator and the\n    second element is an element of `other`.\n\n    The iteration stops, as soon as one of the iterators is exhausted.\n\n    Parameters\n    ----------\n    other : Iterable[U]\n        An Iterable to zip this iterator with\n\n    Returns\n    -------\n    FluentIterator[Tuple[T, U]]\n        Zipped iterator\n\n    Examples\n    --------\n    &gt;&gt;&gt; iterator([\"ping\", \"ping\"]).zip([\"pong\", \"pong\"]).to_list()\n        [(\"ping\", \"pong\"), (\"ping\", \"pong\")]\n    \"\"\"\n    return FluentIterator(zip(self, other))\n</code></pre>"}]}